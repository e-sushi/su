/*

    amu's intermediate representation (AIR). This is the final representation generated by the front-end
    of the compiler. AIR is generated from TAC.

    This representation is used to generate code for different architectures (LLVM for now..), and is used
    by the Interpreter to perform compile time code execution. AIR consists of a sequence of bytecode (BC)
    which stores an opcode, various flags, and then 2 operands or an 8 byte constant.

    BC indexes Registers, which represent values on a stack. AIR can be thought of as having an unlimited
    amount of registers. 

    BC are always of the form
        <instr> <dst> <src>
    but an instruction can take no operands or only one. 

    AIR does not deal with any actual registers or any form of internally stored state. There are no condition
    flags, we just make a temporary value that stores whether some boolean expression is true or false then
    use it as a register where needed. 

    AIR is designed to contain as little information as possible. It does not store references to the information
    that generated it like most other representations do.

    I made sometime in the future setup a map that associates BC with various other representations that generated
    it for debug information. For now, though, printing BC and registers only shows their numeric values.


    NOTES
    ---------
    quirks and such 

    Compile time values are always referenced by their address in memory. Backends are meant to take this 
    memory and put it into whatever temporary thing the backend target supports. For example:
        width :: 5;
        main::()->s32 { a = 5; }
    'width' exists in memory somewhere and the AIR for 'a = 5' will involve a 'push' from that memory address 
    with size 8.

*/

#ifndef AMU_AIR_H
#define AMU_AIR_H

#include "Common.h"
#include "ScalarValue.h"
#include "TAC.h"

namespace amu {

namespace air {
// @genstrings(data/airop_strings.generated)
enum op {
    // pushes the value of A (either a literal or stack offset) onto the stack with size B
    // this is a mix of pushn and copy, but it can copy any arbitrary amount of data
    push, 
    
    pushn, // push A bytes to the stack
    popn, // pop A bytes from the stack
    
    // a 3 operand instruction
    // A: the location to copy to
    // B: the location to copy from
    // C: the amount of data to copy
    // all of the right and left flags still apply normally to A and B
    // TODO(sushi) maybe just make everything 3 operands 
    copy, 

    add, // add B to A and store in A
    sub, // sub B from A and store in A
    mul, // multiply B by A and store in A
    div, // divide B from A and store in A
    mod, // divide B from A and store remainder in A

    // TODO(sushi) consider replacing this 
    eq,  // sets A to one if A == B
    neq, // sets A to one if A != B
    lt,  // sets A to one if A < B
    gt,  // sets A to one if A > B
    le,  // sets A to one if A <= B
    ge,  // sets A to one if A >= B

    call, // jump to the routine pointed to by A with N registers, B,  acting as parameters

    // return from a routine
    // A indicates how much space was made on the stack for the return value
    // the VM will pop the total amount of space made for the function minus this amount
    ret,  
    
    jump,          // jump to a position, A, relative to current instruction
    jump_zero,     // jump to a position, B, relative to current instruction if A is zero
    jump_not_zero, // jump to a position, B, relative to current instruction if A is non_zero

    // intrinsic scalar casting operations
    ftou, // float to unsigned
    ftos, // float to signed 
    itof, // integer to float

    // a 4 operand instruction wow!
    // A: dest of result
    // B: src of result
    // C: type to cast to
    // D: type to cast from
    // this uses the 'resz' struct on BC
    // initially I was just using 2, and then 3, operands omitting the source; which was
    // meant to have been pushed as a temporary that 'destination' pointed at.
    // but this meant that when resizing downwards, the temp spot needed to take on the 
    // larger size to fit its temporary, but then the size of the temp TAC is the size of the
    // original type, so anything using this temporary thinks the size is still the same as it originally was.
    // maybe try and rework this to not use 4 operands later 
    resz, 
 
    // store a pointer to B in A 
    ref,

    // store the value of pointer B in A
    deref,

    vm_break,
	
	// generates a random integer and places the result in A
	intrinsic_rand_int,
	intrinsic_vm_stdout,
};

#include "data/airop_strings.generated"

} // namespace air

// representation of an AIR bytecode
// TODO(sushi) oh my god this is so awful please clean it up soon 
struct BC {
    air::op instr : 6;

    struct {
        b32 left_is_const : 1 = false; // lhs is actually representing a constant value
        b32 left_is_ptr : 1 = false;
        b32 left_is_stack_ptr : 1 = false;
        // the left value is a pointer to something and we want to use the value at that address
        // if 'left_is_ptr' is not set, then we add lhs to the frame pointer and take the value that's there
        b32 deref_left : 1 = false;
        b32 right_is_const : 1 = false; // rhs is actually representing a constant value
        b32 right_is_ptr : 1 = false;
        b32 right_is_stack_ptr : 1 = false;
        b32 deref_right : 1 = false;
        b32 float_op : 1 = false; // this instr is acting on float values
    } flags;

    // the width of the data we're about to operate on 
    width w : 2;

    union{
        struct {
            // either a byte offset into the stack, or a literal value 
            ScalarValue lhs;
            ScalarValue rhs;
        };

        struct { // three operands for copy instructions 
            s64 dst;
            union {
                s64 src;
                ScalarValue literal;
            };
            s64 size;
        }copy;

        struct {
            s64 dst;
            s64 src;
            ScalarValue::Kind to;
            ScalarValue::Kind from;
        } resz;

        struct { // this sucks, setup a way to store functions in 4 bytes instead of 8
            Function* f;
            u32 n_params;
            u32 ret_size;
        };
    };

    // debug comment that gets printed in BC printing 
    String comment;
    ASTNode* node;
    TAC* tac; // the TAC used to generate this

    BC() {}
    BC(const BC& bc) {memory.copy(this, (void*)&bc, sizeof(BC));}
};

void to_string(DString* current, BC bc);

} // namespace amu

#endif // AMU_AIR_H
