/*

    amu's intermediate representation (AIR). This is the final representation generated by the front-end
    of the compiler. AIR is generated from TAC.

    This representation is used to generate code for different architectures (LLVM for now..), and is used
    by the Interpreter to perform compile time code execution. AIR consists of a sequence of bytecode (BC)
    which stores an opcode, various flags, and then 2 operands or an 8 byte constant.

    BC indexes Registers, which represent values on a stack. AIR can be thought of as having an unlimited
    amount of registers. 

    BC are always of the form
        <instr> <dst> <src>
    but an instruction can take no operands or only one. 

    AIR does not deal with any actual registers or any form of internally stored state. There are no condition
    flags, we just make a temporary value that stores whether some boolean expression is true or false then
    use it as a register where needed. 

    AIR is designed to contain as little information as possible. It does not store references to the information
    that generated it like most other representations do.

    I made sometime in the future setup a map that associates BC with various other representations that generated
    it for debug information. For now, though, printing BC and registers only shows their numeric values.

*/

#ifndef AMU_AIR_H
#define AMU_AIR_H

namespace amu {

namespace air {
// @genstrings(data/airop_strings.generated)
enum op {
    // TODO(sushi) these are mostly to keep track of the stack pointer
    //             they replace use of 'copy' when initializing registers
    //             but in the VM no actual allocation of a register takes place
    push, // push a register onto the stack with value A
    // I don't know when this will be used if ever
    pop,  // pop a register from the stack
    popn, // pop A registers from the stack
    
    // pushes A registers to the stack
    // primarily for use at the beginning of functions to make space for their locals 
    pushn, 

    // push a register, A, to the stack
    pushreg, 

    copy, // copy from B to A

    add, // add B to A and store in A
    sub, // sub B from A and store in A
    mul, // multiply B by A and store in A
    div, // divide B from A and store in A

    // TODO(sushi) consider replacing this 
    eq,  // sets A to one if A == B
    neq, // sets A to one if A != B
    lt,  // sets A to one if A < B
    gt,  // sets A to one if A > B
    le,  // sets A to one if A <= B
    ge,  // sets A to one if A >= B

    call, // jump to the routine pointed to by A with N registers, B,  acting as parameters

    // return from a routine
    // A indicates how much space was made on the stack for the return value
    // the VM will pop the total amount of space made for the function minus this amount
    ret,  
    
    jump,          // jump to a position, A, relative to current instruction
    jump_zero,     // jump to a position, B, relative to current instruction if A is zero
    jump_not_zero, // jump to a position, B, relative to current instruction if A is non_zero
};

#include "data/airop_strings.generated"

} // namespace air

// representation of a slot on the VM's stack
struct Register{
    union {
        u8* ptr;

        u64 _u64;
        u32 _u32;
        u16 _u16;
        u8  _u8;

        s64 _s64;
        s32 _s32;
        s16 _s16;
        s8  _s8;

        f64 _f64;
        f32 _f32;
    };
};

// representation of an AIR bytecode
struct BC {
    air::op instr : 6;

    struct {
        b32 left_is_const : 1 = false; // offset_a is actually representing a constant value 
        b32 right_is_const : 1 = false; // offset_b is actually representing a constant value 
        b32 float_op : 1 = false; // this instr is acting on float values
    } flags;

    union{
        struct {
            s32 offset_a;
            s32 offset_b;
        };
        u64 constant;
        struct { // this sucks, setup a way to store functions in 4 bytes instead of 8
            Function* f;
            u32 n_params;
            u32 ret_size;
        };
    };

    String comment;
};

void
to_string(DString& current, BC bc) {

    auto loffset = [&]() {
        if(bc.flags.left_is_const) {
            dstring::append(current, bc.offset_a, " ");
        } else {
            dstring::append(current, "r", bc.offset_a, " ");
        }
    };

    auto roffset = [&]() {
        if(bc.flags.left_is_const) {
            dstring::append(current, bc.offset_b);
        } else {
            dstring::append(current, "r", bc.offset_b);
        }
    };

    switch(bc.instr) {
        case air::push:{
            dstring::append(current, "push ");
            loffset();
        }break;
        case air::pop:{
            dstring::append(current, "pop ");
            loffset();
        }break;
        case air::popn:{
            dstring::append(current, "popn ");
            loffset();
        }break;
        case air::pushn:{
            dstring::append(current, "pushn ");
            loffset();
        }break;
        case air::copy:{
            dstring::append(current, "copy ");
            loffset();
            roffset();
        }break;
        case air::add:{
            dstring::append(current, "add ");
            loffset();
            roffset();
        }break;
        case air::sub:{
            dstring::append(current, "sub ");
            loffset();
            roffset();
        }break;
        case air::mul:{
            dstring::append(current, "mul ");
            loffset();
            roffset();
        }break;
        case air::div:{
            dstring::append(current, "div ");
            loffset();
            roffset();
        }break;
        case air::eq:{
            dstring::append(current, "eq ");
            loffset();
            roffset();
        }break;
        case air::neq:{
            dstring::append(current, "neq ");
            loffset();
            roffset();
        }break;
        case air::lt:{
            dstring::append(current, "lt ");
            loffset();
            roffset();
        }break;
        case air::gt:{
            dstring::append(current, "gt ");
            loffset();
            roffset();
        }break;
        case air::le:{
            dstring::append(current, "le ");
            loffset();
            roffset();
        }break;
        case air::ge:{
            dstring::append(current, "ge ");
            loffset();
            roffset();
        }break;
        case air::call:{
            dstring::append(current, "call ");
            dstring::append(current, bc.f->name(), " ");
            dstring::append(current, bc.n_params);
        }break;
        case air::ret:{
            dstring::append(current, "ret ");
            loffset();
        }break;
        case air::jump:{
            dstring::append(current, "jmp ");
            loffset();
        }break;
        case air::jump_zero:{
            dstring::append(current, "jz ");
            loffset();
            roffset();
        }break;
        case air::jump_not_zero:{
            dstring::append(current, "jnz ");
            loffset();
            roffset();
        }break;
    }

    if(bc.comment.str) {
        dstring::append(current, "  --# ", bc.comment);
    }
}

DString
to_string(BC bc) {
    DString out = dstring::init();
    to_string(out, bc);
    return out;
}

void
to_string(DString& current, Register r) {
}

DString
to_string(Register r) {
    DString out = dstring::init();
    to_string(out, r);
    return out;
}

} // namespace amu

#endif // AMU_AIR_H
