/*

    amu's intermediate representation (AIR). This is the final representation generated by the front-end
    of the compiler. AIR is generated from TAC.

    This representation is used to generate code for different architectures (LLVM for now..), and is used
    by the Interpreter to perform compile time code execution. AIR consists of a sequence of bytecode (BC)
    which stores an opcode, various flags, and then 2 operands or an 8 byte constant.

    BC indexes Registers, which represent values on a stack. AIR can be thought of as having an unlimited
    amount of registers. 

    BC are always of the form
        <instr> <dst> <src>
    but an instruction can take no operands or only one. 

    AIR does not deal with any actual registers or any form of internally stored state. There are no condition
    flags, we just make a temporary value that stores whether some boolean expression is true or false then
    use it as a register where needed. 

    AIR is designed to contain as little information as possible. It does not store references to the information
    that generated it like most other representations do.

    I made sometime in the future setup a map that associates BC with various other representations that generated
    it for debug information. For now, though, printing BC and registers only shows their numeric values.

*/

#ifndef AMU_AIR_H
#define AMU_AIR_H

namespace amu {

namespace air {
// @genstrings(data/airop_strings.generated)
enum op {
    // pushes the value of A (either a literal or stack offset) onto the stack with size B
    // this is a mix of pushn and copy, but it can copy any arbitrary amount of data
    push, 
    
    pushn, // push A bytes to the stack
    popn, // pop A bytes from the stack
    
    copy, // copy from B to A

    add, // add B to A and store in A
    sub, // sub B from A and store in A
    mul, // multiply B by A and store in A
    div, // divide B from A and store in A

    // TODO(sushi) consider replacing this 
    eq,  // sets A to one if A == B
    neq, // sets A to one if A != B
    lt,  // sets A to one if A < B
    gt,  // sets A to one if A > B
    le,  // sets A to one if A <= B
    ge,  // sets A to one if A >= B

    call, // jump to the routine pointed to by A with N registers, B,  acting as parameters

    // return from a routine
    // A indicates how much space was made on the stack for the return value
    // the VM will pop the total amount of space made for the function minus this amount
    ret,  
    
    jump,          // jump to a position, A, relative to current instruction
    jump_zero,     // jump to a position, B, relative to current instruction if A is zero
    jump_not_zero, // jump to a position, B, relative to current instruction if A is non_zero
};

#include "data/airop_strings.generated"

} // namespace air

// representation of a slot on the VM's stack
// NOTE(sushi) I'm abandoning this for now (23/09/04) in favor of just using byte offsets 
//             because dealing with data split into several parts smaller than u64 gets annoying.
//             I will definitely come back to this, likely as a wrapper over the data to segment it
//             into 8 byte chunks so that allocating registers is easier when we move to implementing
//             our own backends
struct Register{
    union {
        u8* ptr;

        u64 _u64;
        u32 _u32;
        u16 _u16;
        u8  _u8;

        s64 _s64;
        s32 _s32;
        s16 _s16;
        s8  _s8;

        f64 _f64;
        f32 _f32;
    };
};

enum width {
    byte = 0, // 1 byte
    word = 1, // 2 bytes
    dble = 2, // 4 bytes
    quad = 3, // 8 bytes
};  

// representation of an AIR bytecode
struct BC {
    air::op instr : 6;

    struct {
        b32 left_is_const : 1 = false; // lhs is actually representing a constant value 
        b32 right_is_const : 1 = false; // rhs is actually representing a constant value 
        b32 float_op : 1 = false; // this instr is acting on float values
    } flags;

    // the width of the data we're about to operate on 
    width w : 2;

    union{
        struct {
            // either a byte offset into the stack, or a literal value 
            s32 lhs;
            union {
                s32 rhs;
                f64 rhs_f;
            };
        };
        // large literal value 
        u64 constant;
        struct { // this sucks, setup a way to store functions in 4 bytes instead of 8
            Function* f;
            u32 n_params;
            u32 ret_size;
        };
    };

    // debug comment that gets printed in BC printing 
    String comment;
};

void
to_string(DString*& current, BC bc) {

    auto loffset = [&]() {
        if(bc.flags.left_is_const) {
            current->append(bc.lhs, " ");
        } else {
            current->append("(sp + ", bc.lhs, ") ");
        }
    };

    auto roffset = [&]() {
        if(bc.flags.right_is_const || bc.flags.float_op) {
            if(bc.flags.float_op) {
                current->append(bc.rhs_f);
            } else {
                current->append(bc.rhs);
            }
        } else {
            current->append("(sp + ", bc.rhs, ")");
        }
    };

    switch(bc.instr) {
        case air::push:{
            current->append("push ");
            loffset();
            roffset();
        }break;
        case air::popn:{
            current->append("popn ");
            loffset();
        }break;
        case air::pushn:{
            current->append("pushn ");
            loffset();
        }break;
        case air::copy:{
            current->append("copy ");
            loffset();
            roffset();
        }break;
        case air::add:{
            current->append("add ");
            loffset();
            roffset();
        }break;
        case air::sub:{
            current->append("sub ");
            loffset();
            roffset();
        }break;
        case air::mul:{
            current->append("mul ");
            loffset();
            roffset();
        }break;
        case air::div:{
            current->append("div ");
            loffset();
            roffset();
        }break;
        case air::eq:{
            current->append("eq ");
            loffset();
            roffset();
        }break;
        case air::neq:{
            current->append("neq ");
            loffset();
            roffset();
        }break;
        case air::lt:{
            current->append("lt ");
            loffset();
            roffset();
        }break;
        case air::gt:{
            current->append("gt ");
            loffset();
            roffset();
        }break;
        case air::le:{
            current->append("le ");
            loffset();
            roffset();
        }break;
        case air::ge:{
            current->append("ge ");
            loffset();
            roffset();
        }break;
        case air::call:{
            current->append("call ");
            current->append(bc.f->name(), " ");
            current->append(bc.n_params);
        }break;
        case air::ret:{
            current->append("ret ");
            loffset();
        }break;
        case air::jump:{
            current->append("jmp ");
            loffset();
        }break;
        case air::jump_zero:{
            current->append("jz ");
            loffset();
            roffset();
        }break;
        case air::jump_not_zero:{
            current->append("jnz ");
            loffset();
            roffset();
        }break;
    }

    current->append(" w: ", (u32)bc.w+1);

    if(bc.comment.str) {
        current->append("  --# ", bc.comment);
    }
}

DString*
to_string(BC bc) {
    DString* out = DString::create();
    to_string(out, bc);
    return out;
}

void
to_string(DString*& current, Register r) {
}

DString*
to_string(Register r) {
    DString* out = DString::create();
    to_string(out, r);
    return out;
}

} // namespace amu

#endif // AMU_AIR_H
