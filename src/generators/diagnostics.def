// This file defines all diagnostics that amu may emit while compiling code
// The format is
// group <id> {
//   diagnostic <id> {
//      type: [ error | warning ];
//        message: {
//            <language-code> : <string>
//        }
//   }
// }
//
// The string may request arguments from the creator of the diagnostic, which will be 
// interpolated into the message emitted by the diagnostic. Most of these will have internal
// formatting options associated with them, such as prefix/suffix, coloring, and other misc options
// The logic for formatting is found in Messenger.h/cpp
//
//
//      %String% - a plain String must be passed
//      %path$ - a String representing a path
//      %identifier% - a String representing an identifier must be passed 
//      %token% - a Token must be passed
//      %type% - a Type must be passed
//
//      
// A message may backreference any argument it requested using the syntax $<id>$

group path {
    diagnostic not_found {
        type: error;
        message: {
            en: "the path %path% could not be found";
            esp: "la vojo %path% maltroveblis";
        }
    }
}

group compiler {
    diagnostic expected_a_path_for_arg {
        type: error;
        message: {
            en: "expected a path for arg '%String%'";
            esp: "atendis vojopor argumento '%String%'";
        }
    }

    diagnostic unknown_option {
        type: error;
        message: {
            en: "unknown option '%String%'";
            esp: "nekonata opcio '%String%'";
        }
    }

    diagnostic no_path_given {
        type: error;
        message: {
            en: "no input file";
        }
    }

    diagnostic expected_path_or_paths_for_arg_option {
        type: error;
        message: {
            en: "expected a path or paths for argument option '%String%'";
        }
    }
}

group lexer {
    diagnostic unexpected_eof_single_quotes {
        type: error;
        message: {
            en: "unexpected EOF encountered while parsing single quotes";
            jp: "一重引用符は解析すながら予期せぬファイルの終わり見つかり";
        }
    }

    diagnostic unexpected_eof_double_quotes {
        type: error;
        message: {
            en: "unexpected EOF encountered while parsing double quotes";
            jp: "二重引用符は解析すながら予期せぬファイルの終わり見つかり";
        }
    }

    diagnostic multiline_comment_missing_end {
        type: error;
        message: {
            en: "multiline comment missing '*/'";
            jp: "複数行コメントの'*/'がぬけています";
        }
    }

    diagnostic unknown_directive {
        type: error;
        message: {
            en: "unknown directive %identifier%";
            jp: "不明の命令%identifier%";
        }
    }

    diagnostic invalid_token {
        type: error;
        message: {
            en: "invalid token";
            jp: "無効のトークン";
        }
    }
}

group parser {
    diagnostic expected_type {
        type: error;
        message: {
            en: "expected a type";
            jp: "タイプが期待した";
        }
    }

    diagnostic expected_label_or_import {
        type: error;
        message: {
            en: "expected a label or import";
            jp: "名札か輸入が期待した";
        }
    }

    diagnostic expected_identifier {
        type: error;
        message: {
            en: "expected an identifier";
            jp: "識別名が期待した";
        }
    }

    diagnostic expected_import_directive {
        type: error;
        message: {
            en: "expected an import directive";
            jp: "輸入命令が期待した";
        }
    }

    diagnostic expected_colon_for_label {
        type: error;
        message: {
            en: "expected a ':' after label(s)";
            jp: "ラベルの後にコロンが必要";
        }
    }

    diagnostic unknown_identifier {
        type: error;
        message: {
            en: "reference to unknown identifier.";
        }
    }

    diagnostic expected_comma_or_closing_paren_tuple {
        type: error;
        message: {
            en: "expected a ',' or ')' for tuple";
        }
    }

    diagnostic unexpected_token {
        type: error;
        message: {
            en: "unexpected token %token%";
        }
    }

    diagnostic expected_open_paren {
        type: error;
        message: {
            en: "expected a '('";
        }
    }

    diagnostic expected_close_paren {
        type: error;
        message: {
            en: "expected a ')'";
        }
    }

    diagnostic expected_open_brace {
        type: error;
        message: {
            en: "expected a '{'";
        }
    }

    diagnostic expected_close_brace {
        type: error;
        message: {
            en: "expected a '}'";
        }
    }

    diagnostic label_group_missing_id {
        type: error;
        message: {
            en: "trailing comma not allowed in multi-label declaration";
        }
    }

    diagnostic label_missing_colon {
        type: error;
        message: {
            en: "missing a ':' after label identifier(s)";
        }
    }

    diagnostic switch_missing_open_paren {
        type: error;
        message: {
            en: "missing a '(' after 'switch'";
        }
    }

    diagnostic switch_missing_close_paren {
        type: error;
        message: {
            en: "missing a ')' after switch's expression";
        }
    }

    diagnostic switch_missing_open_brace {
        type: error;
        message: {
            en: "missing a '{' to start switch expression";
        }
    }

    diagnostic switch_empty_body {
        type: warning;
        message: {
            en: "empty switch body";
        }
    }

    diagnostic switch_missing_match_arrow_after_expr {
        type: error;
        message: {
            en: "expected a '=>' after expression in switch expression";
        }
    }

    diagnostic switch_missing_comma_after_match_arm {
        type: error;
        message: {
            en: "expected a ',' after switch arm that does not end with a '}'";
        }
    }

    diagnostic for_missing_open_paren {
        type: error;
        message: {
            en: "missing a '(' after 'for'";
        }
    }

    diagnostic for_missing_close_paren {
        type: error;
        message: {
            en: "missing a ')' after for's expression";
        }
    }

    diagnostic for_expected_some_identfier {
        type: error;
        message: {
            en: "expected some identifier to begin 'for' clause";
        }
    }

    diagnostic for_label_group_not_allowed {
        type: error;
        message: {
            en: "multi label definition is not allowed in C style for loops.";
        }
    }

    diagnostic for_expected_in {
        type: error;
        message: {
            en: "expected 'in' for 'for' clause";
        }
    }

    diagnostic tuple_expected_comma_or_close_paren {
        type: error;
        message: {
            en: "expected a ',' or ')' for tuple";
        }
    }

    diagnostic tuple_positional_arg_but_found_label {
        type: error;
        message: {
            en: "all elements after a named tuple element must also be named";
        }
    }

    diagnostic if_missing_open_paren {
        type: error;
        message: {
            en: "missing '(' after 'if'";
        }
    }

    diagnostic if_missing_close_paren {
        type: error;
        message: {
            en: "missing ')' after if expression's condition";
        }
    }

    diagnostic missing_semicolon {
        type: error;
        message: {
            en: "missing ';'";
        }
    }

    diagnostic missing_function_return_type {
        type: error;
        message: {
            en: "missing return type(s) for function";
        }
    }

    diagnostic missing_open_brace_for_struct {
        type: error;
        message: {
            en: "missing '{' after 'struct'";
        }
    }

    diagnostic struct_only_labels_allowed {
        type: error;
        message: {
            en: "only labels are allowed in structures";
        }
    }

    diagnostic struct_member_functions_not_allowed {
        type: error;
        message: {
            en: "member functions are not allowed";
        }
    }

    diagnostic extraneous_close_brace {
        type: error;
        message: {
            en: "extraneous closing blace '}'";
        }
    }

    diagnostic unexpected_token_in_module {
        type: error;
        message: {
            en: "unexpected token in module, only labels and directives are allowed";
        }
    }
}

group sema {
    diagnostic func_ret_expected_typeref {
        type: error;
        message: {
            en: "expected a type reference for function return type";
        }
    }

    diagnostic cannot_implict_coerce {
        type: error;
        message: {
            en: "the type %type:from_type% does not define trait ImplicitCast to type %type:to_type%";
            esp: "la tipo %type% ne difinas la trajton ImplicitCast al tipo %type%";
        }
    }

    diagnostic cant_find_binop_trait {
        type: error;
        message: {
            en: "the trait %String:trait_name% is not defined between %type% and %type%";
        }
    }

    diagnostic mismatch_argument_type {
        type: error;
        message: {
            en: "cannot convert type %type:arg_type% to %type:param_type% for argument %String:arg_str% in call to %String:func_name%";
        }
    }

    diagnostic too_many_arguments {
        type: error;
        message: {
            en: "too many arguments provided in call to %String%";
        }
    }
    

    diagnostic not_enough_arguments {
        type: error;
        message: {
            en: "not enough arguments provided in call to %String%";
        }
    }

    diagnostic invalid_type_lhs_access {
        type: error;
        message: {
            en: "unable to resolve the type of the lhs of access operator";
        }
    }

    diagnostic cannot_access_members_scalar_type {
        type: error;
        message: {
            en: "scalar types have no members";
        }
    }

    diagnostic array_types_dont_have_member {
        type: error;
        message: {
            en: "array types dont have a member %String%";
        }
    }

    diagnostic cannot_access_members_of_function_type {
        type: error;
        message: {
            en: "cannot access members of a function type";
        }
    }

    diagnostic too_many_levels_of_indirection_for_access {
        type: error;
        message: {
            en: "too many levels of indirection for access operator. The access operator will only dereference once.";
        }
    }
    
    diagnostic unknown_member {
        type: error;
        message: {
            en: "type %type:type% has no member named %String:member_name%";
        }
    }

    diagnostic cannot_have_a_variable_of_void_type {
        type: error;
        message: {
            en: "cannot create a variable of type 'void'";
        }
    }

    diagnostic if_mismatched_types_cannot_coerce {
        type: error;
        message: {
            en: "conditional branches have mismatched types and the ladder type %type:first_type% cannot be converted to the former %type:later_type%";
        }
    }

    diagnostic return_value_of_func_block_cannot_be_coerced_to_func_return_type {
        type: error;
        message: {
            en: "function return type declared as %type:func_type% but block returns %type:block_type% and $1$ does not define ImplicitCast to $0$";
        }
    }

    diagnostic break_outside_of_loop {
        type: error;
        message: {
            en: "break expressions must be used in loops";
        }
    }

    diagnostic cant_use_whatever_as_value {
        type: error;
        message: {
            en: "type Whatever cannot be used as a value";
        }
    }
}

group internal {
    diagnostic valid_path_but_internal_err {
        type: error;
        message: {
            en: "valid path, %path%, was given, but couldn't be opened due to an internal error: %String%";
        }
    }
}