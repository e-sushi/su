use MONKEY-SEE-NO-EVAL;
# use trace;

chdir '..';

my regex Comment { '//'.* } 
my regex NotAfterComment { <!after '//'.*> }

my @path_stack = '.'.IO;
while @path_stack {
    for @path_stack.pop.dir -> $path {
        @path_stack.push($path) and next if $path.d;
        my $fh = open $path;
        for $fh.lines.kv -> $num, $line {
            # if the line is empty, just continue
            next unless $line;
            when $line ~~ /\@genstrings\((.*)\)/ {
                say "found in {$fh.path} on line $num:\n\t$line";
                genstrings(($fh, $fh.path, $num), $0) 
            }
        }
    }
}

sub genstrings($fileinfo, $arglist) {
    my @args = $arglist.split(/<!after \\>\,/);
    
    my $fh = $fileinfo[0];
    my $filepath = $fileinfo[1];
    my $linenum = $fileinfo[2];

    # open file specified by command
    my $out = open @args[0], :w or die "couldn't open given file: @args[0]";
    # generate subsitution functions from the rest of the arguments
    my @subs = gather for @args[1..*] -> $arg {
        take EVAL "-> \$str \{ $arg given \$str \}";
    }

    $fh.get ~~ /enum/ or 
        die "genstrings not followed by an enum!";

    my @elems = ();
    for $fh.lines -> $line {
        # if this line has an rbrace that is not preceeded by `//` it must be the end of the enum
        last if $line ~~ rx|<NotAfterComment>\}|;
        # split up the line by commas that aren't in a comment
        for $line.split(rx|<NotAfterComment>\,|) -> $elem is copy {
            $elem ~~ s:g/'='.*//; # remove any values being set
            $elem ~~ s:g/<Comment>//; # replace comments with nothing
            $elem ~~ s:g/^\s+|\s+$//; # strip whitespace on left and right
            @elems.push: $elem if $elem;
        }
    }

    # apply custom subsitutions to each element
    @elems = gather for @elems -> $elem is rw {
        $elem = $_($elem) for @subs;
        take $elem if $elem;
    }

    my $time = DateTime.now(
        formatter=>{
            sprintf "%04d/%02d/%02d %02d:%02d:%02d", .year, .month, .day, .hour, .minute, .second given $^self
        });

    # output header
    $out.say(
"/* {$time.Instant.to-posix[0].Int} [$time] 
    generated by datagen.raku from $filepath:$linenum 
*/");

    $out.say('const global String strings[] = {');

    for @elems -> $elem {
        $out.say("\t\"$elem\",");
    }

    $out.say('};');
}