/* 1694851641 [2023/09/16 01:07:21]
    generated by diagnostics.raku from diagnostics.def
*/
namespace amu {
namespace diagnostic {
language lang;
namespace path {
FORCE_INLINE global void
not_found(MessageSender sender, String arg0) {
	Diagnostic diag = {0};
	diag.code = 1;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("the path "));
			message::push(out, message::path(arg0));
			message::push(out, String(" could not be found"));
		} break;
		case esp: {
			message::push(out, String("la vojo "));
			message::push(out, message::path(arg0));
			message::push(out, String(" maltroveblis"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

} // namespace path

namespace compiler {
FORCE_INLINE global void
expected_a_path_for_arg(MessageSender sender, String arg0) {
	Diagnostic diag = {0};
	diag.code = 2;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a path for arg '"));
			message::push(out, arg0);
			message::push(out, String("'"));
		} break;
		case esp: {
			message::push(out, String("atendis vojopor argumento '"));
			message::push(out, arg0);
			message::push(out, String("'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
unknown_option(MessageSender sender, String arg0) {
	Diagnostic diag = {0};
	diag.code = 3;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("unknown option '"));
			message::push(out, arg0);
			message::push(out, String("'"));
		} break;
		case esp: {
			message::push(out, String("nekonata opcio '"));
			message::push(out, arg0);
			message::push(out, String("'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
no_path_given(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 4;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("no input file"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
expected_path_or_paths_for_arg_option(MessageSender sender, String arg0) {
	Diagnostic diag = {0};
	diag.code = 5;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a path or paths for argument option '"));
			message::push(out, arg0);
			message::push(out, String("'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

} // namespace compiler

namespace lexer {
FORCE_INLINE global void
unexpected_eof_single_quotes(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 6;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("unexpected EOF encountered while parsing single quotes"));
		} break;
		case jp: {
			message::push(out, String("一重引用符は解析すながら予期せぬファイルの終わり見つかり"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
unexpected_eof_double_quotes(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 7;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("unexpected EOF encountered while parsing double quotes"));
		} break;
		case jp: {
			message::push(out, String("二重引用符は解析すながら予期せぬファイルの終わり見つかり"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
multiline_comment_missing_end(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 8;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("multiline comment missing '*/'"));
		} break;
		case jp: {
			message::push(out, String("複数行コメントの'*/'がぬけています"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
unknown_directive(MessageSender sender, String arg0) {
	Diagnostic diag = {0};
	diag.code = 9;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("unknown directive "));
			message::push(out, message::identifier(arg0));
		} break;
		case jp: {
			message::push(out, String("不明の命令"));
			message::push(out, message::identifier(arg0));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
invalid_token(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 10;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("invalid token"));
		} break;
		case jp: {
			message::push(out, String("無効のトークン"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

} // namespace lexer

namespace parser {
FORCE_INLINE global void
expected_type(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 11;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a type"));
		} break;
		case jp: {
			message::push(out, String("タイプが期待した"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
expected_label_or_import(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 12;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a label or import"));
		} break;
		case jp: {
			message::push(out, String("名札か輸入が期待した"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
expected_identifier(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 13;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected an identifier"));
		} break;
		case jp: {
			message::push(out, String("識別名が期待した"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
expected_import_directive(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 14;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected an import directive"));
		} break;
		case jp: {
			message::push(out, String("輸入命令が期待した"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
expected_colon_for_label(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 15;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a ':' after label(s)"));
		} break;
		case jp: {
			message::push(out, String("ラベルの後にコロンが必要"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
unknown_identifier(MessageSender sender, Token* arg0) {
	Diagnostic diag = {0};
	diag.code = 16;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("reference to unknown identifier: "));
			message::push(out, arg0);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
label_already_defined(MessageSender sender, Token* arg0) {
	Diagnostic diag = {0};
	diag.code = 17;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("the label "));
			message::push(out, arg0);
			message::push(out, String(" has already been defined in this scope"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
missing_close_brace(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 18;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing a close brace for this opening brace (I think)"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
expected_comma_or_closing_paren_tuple(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 19;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a ',' or ')' for tuple"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
unexpected_token(MessageSender sender, Token* arg0) {
	Diagnostic diag = {0};
	diag.code = 20;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("unexpected token "));
			message::push(out, arg0);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
expected_open_paren(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 21;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a '('"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
expected_close_paren(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 22;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a ')'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
expected_open_brace(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 23;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a '{'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
expected_close_brace(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 24;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a '}'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
label_group_missing_id(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 25;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("trailing comma not allowed in multi-label declaration"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
label_missing_colon(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 26;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing a ':' after label identifier(s)"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
switch_missing_open_paren(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 27;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing a '(' after 'switch'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
switch_missing_close_paren(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 28;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing a ')' after switch's expression"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
switch_missing_open_brace(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 29;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing a '{' to start switch expression"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
switch_empty_body(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 30;
	diag.severity = diagnostic::warning;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::warning;
	switch(lang) {
		case en: {
			message::push(out, String("empty switch body"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
switch_missing_match_arrow_after_expr(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 31;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a '=>' after expression in switch expression"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
switch_missing_comma_after_match_arm(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 32;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a ',' after switch arm that does not end with a '}'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
for_missing_open_paren(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 33;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing a '(' after 'for'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
for_missing_close_paren(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 34;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing a ')' after for's expression"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
for_expected_some_identfier(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 35;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected some identifier to begin 'for' clause"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
for_label_group_not_allowed(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 36;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("multi label definition is not allowed in C style for loops."));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
for_expected_in(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 37;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected 'in' for 'for' clause"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
tuple_expected_comma_or_close_paren(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 38;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a ',' or ')' for tuple"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
array_expected_comma_or_close_square(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 39;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a ',' or ']' for array"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
tuple_positional_arg_but_found_label(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 40;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("all elements after a named tuple element must also be named"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
if_missing_open_paren(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 41;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing '(' after 'if'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
if_missing_close_paren(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 42;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing ')' after if expression's condition"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
missing_semicolon(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 43;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing ';'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
missing_function_return_type(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 44;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing return type(s) for function"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
missing_open_brace_for_struct(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 45;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing '{' after 'struct'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
struct_only_labels_allowed(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 46;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("only labels are allowed in structures"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
struct_member_functions_not_allowed(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 47;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("member functions are not allowed"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
extraneous_close_brace(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 48;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("extraneous closing blace '}'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
unexpected_token_in_module(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 49;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("unexpected token in module, only labels and directives are allowed"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
array_missing_close_square(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 50;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing ']' to close array type"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
runtime_structures_not_allowed(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 51;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("structure types cannot be defined in runtime memory (did you forget a ':'? or did you use '=' instead of ':'?)"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
struct_duplicate_member_name(MessageSender sender, Token* arg0) {
	Diagnostic diag = {0};
	diag.code = 52;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("member "));
			message::push(out, arg0);
			message::push(out, String(" already defined."));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
static_array_count_must_eval_to_integer(MessageSender sender, Type* arg0) {
	Diagnostic diag = {0};
	diag.code = 53;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("static array count must evaluate to a compile time integer, but found "));
			message::push(out, arg0);
			message::push(out, String(" instead"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
static_array_size_cannot_be_negative(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 54;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("static array count cannot be negative"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
subscript_missing_close_square(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 55;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("subscript operator missing closing square ']'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

} // namespace parser

namespace sema {
FORCE_INLINE global void
func_ret_expected_typeref(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 56;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a type reference for function return type"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
cannot_implict_coerce(MessageSender sender, Type* from_type, Type* to_type) {
	Diagnostic diag = {0};
	diag.code = 57;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("the type "));
			message::push(out, from_type);
			message::push(out, String(" does not define trait ImplicitCast to type "));
			message::push(out, to_type);
		} break;
		case esp: {
			message::push(out, String("la tipo "));
			message::push(out, from_type);
			message::push(out, String(" ne difinas la trajton ImplicitCast al tipo "));
			message::push(out, to_type);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
cant_find_binop_trait(MessageSender sender, String trait_name, Type* arg1, Type* arg2) {
	Diagnostic diag = {0};
	diag.code = 58;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("the trait "));
			message::push(out, trait_name);
			message::push(out, String(" is not defined between "));
			message::push(out, arg1);
			message::push(out, String(" and "));
			message::push(out, arg2);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
mismatch_argument_type(MessageSender sender, Type* arg_type, Type* param_type, String arg_str, String func_name) {
	Diagnostic diag = {0};
	diag.code = 59;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("cannot convert type "));
			message::push(out, arg_type);
			message::push(out, String(" to "));
			message::push(out, param_type);
			message::push(out, String(" for argument "));
			message::push(out, arg_str);
			message::push(out, String(" in call to "));
			message::push(out, func_name);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
too_many_arguments(MessageSender sender, String arg0) {
	Diagnostic diag = {0};
	diag.code = 60;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("too many arguments provided in call to "));
			message::push(out, arg0);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
not_enough_arguments(MessageSender sender, String arg0) {
	Diagnostic diag = {0};
	diag.code = 61;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("not enough arguments provided in call to "));
			message::push(out, arg0);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
invalid_type_lhs_access(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 62;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("unable to resolve the type of the lhs of access operator"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
cannot_access_members_scalar_type(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 63;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("scalar types have no members"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
array_types_dont_have_member(MessageSender sender, String arg0) {
	Diagnostic diag = {0};
	diag.code = 64;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("array types dont have a member "));
			message::push(out, arg0);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
cannot_access_members_of_function_type(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 65;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("cannot access members of a function type"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
too_many_levels_of_indirection_for_access(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 66;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("too many levels of indirection for access operator. The access operator will only dereference once."));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
unknown_member(MessageSender sender, Type* type, String member_name) {
	Diagnostic diag = {0};
	diag.code = 67;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("type "));
			message::push(out, type);
			message::push(out, String(" has no member named "));
			message::push(out, member_name);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
cannot_have_a_variable_of_void_type(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 68;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("cannot create a variable of type 'void'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
if_mismatched_types_cannot_coerce(MessageSender sender, Type* first_type, Type* later_type) {
	Diagnostic diag = {0};
	diag.code = 69;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("conditional branches have mismatched types and the ladder type "));
			message::push(out, first_type);
			message::push(out, String(" cannot be converted to the former "));
			message::push(out, later_type);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
return_value_of_func_block_cannot_be_coerced_to_func_return_type(MessageSender sender, Type* func_type, Type* block_type) {
	Diagnostic diag = {0};
	diag.code = 70;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("function return type declared as "));
			message::push(out, func_type);
			message::push(out, String(" but block returns "));
			message::push(out, block_type);
			message::push(out, String(" and "));
			message::push(out, block_type);
			message::push(out, String(" does not define ImplicitCast to "));
			message::push(out, func_type);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
break_outside_of_loop(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 71;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("break expressions must be used in loops"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
cant_use_whatever_as_value(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 72;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("type Whatever cannot be used as a value"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
cant_use_whatever_as_variable_type(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 73;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("cannot have a variable of type Whatever"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
control_expressions_can_only_be_used_at_the_end_of_logical_operators(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 74;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("control expressions can only be used at the very right of logical operators"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
compile_time_code_cannot_reference_runtime_memory(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 75;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("compile time code cannot reference runtime memory"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
array_literal_type_mismatch(MessageSender sender, s64 elem_index, Type* bad_type, Type* first_type) {
	Diagnostic diag = {0};
	diag.code = 76;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("array element "));
			message::push(out, to_string(elem_index)->fin);
			message::push(out, String(" is of type "));
			message::push(out, bad_type);
			message::push(out, String(" which does not define ImplicitCast to the first element's type "));
			message::push(out, first_type);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
type_is_not_subscriptable(MessageSender sender, Type* arg0) {
	Diagnostic diag = {0};
	diag.code = 77;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("the type "));
			message::push(out, arg0);
			message::push(out, String(" cannot be subscripted"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
subscript_must_evaluate_to_integer(MessageSender sender, Type* arg0) {
	Diagnostic diag = {0};
	diag.code = 78;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("a subscript must evaluate to an integer (or, eventually, a range of integers), but this evaluates to "));
			message::push(out, arg0);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
subscript_out_of_bounds(MessageSender sender, s64 bad_guy, s64 array_size) {
	Diagnostic diag = {0};
	diag.code = 79;
	diag.severity = diagnostic::warning;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::warning;
	switch(lang) {
		case en: {
			message::push(out, String("the subscript "));
			message::push(out, to_string(bad_guy)->fin);
			message::push(out, String(" is out of bounds of static array of size "));
			message::push(out, to_string(array_size)->fin);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
subscript_negative_not_allowed_on_pointer(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 80;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("negative subscripts on pointers aren't defined"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

} // namespace sema

namespace internal {
FORCE_INLINE global void
valid_path_but_internal_err(MessageSender sender, String arg0, String arg1) {
	Diagnostic diag = {0};
	diag.code = 81;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else code::add_diagnostic(sender.code, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("valid path, "));
			message::push(out, message::path(arg0));
			message::push(out, String(", was given, but couldn't be opened due to an internal error: "));
			message::push(out, arg1);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

} // namespace internal

} // namespace diagnostic
} // namespace amu
