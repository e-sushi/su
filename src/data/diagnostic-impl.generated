/* 1689712910 [2023/07/18 16:41:50]
    generated by diagnostics.raku from diagnostics.def
*/
namespace amu {
namespace diagnostic {
language lang;
namespace path {
FORCE_INLINE global void
not_found(MessageSender sender, String arg0) {
	Diagnostic diag = {0};
	diag.code = 0;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("the path "));
			message::push(out, message::path(arg0));
			message::push(out, String(" cound not be found"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

} // namespace path

namespace compiler {
FORCE_INLINE global void
expected_a_path_for_arg(MessageSender sender, String arg0) {
	Diagnostic diag = {0};
	diag.code = 1;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a path for arg '"));
			message::push(out, arg0);
			message::push(out, String("'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
unknown_option(MessageSender sender, String arg0) {
	Diagnostic diag = {0};
	diag.code = 2;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("unknown option '"));
			message::push(out, arg0);
			message::push(out, String("'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
no_path_given(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 3;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("no input file"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
expected_path_or_paths_for_arg_option(MessageSender sender, String arg0) {
	Diagnostic diag = {0};
	diag.code = 4;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a path or paths for argument option '"));
			message::push(out, arg0);
			message::push(out, String("'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

} // namespace compiler

namespace lexer {
FORCE_INLINE global void
unexpected_eof_single_quotes(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 5;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("unexpected EOF encountered while parsing single quotes"));
		} break;
		case jp: {
			message::push(out, String("一重引用符は解析すながら予期せぬファイルの終わり見つかり"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
unexpected_eof_double_quotes(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 6;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("unexpected EOF encountered while parsing double quotes"));
		} break;
		case jp: {
			message::push(out, String("二重引用符は解析すながら予期せぬファイルの終わり見つかり"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
multiline_comment_missing_end(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 7;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("multiline comment missing '*/'"));
		} break;
		case jp: {
			message::push(out, String("複数行コメントの'*/'がぬけています"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
unknown_directive(MessageSender sender, String arg0) {
	Diagnostic diag = {0};
	diag.code = 8;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("unknown directive "));
			message::push(out, message::identifier(arg0));
		} break;
		case jp: {
			message::push(out, String("不明の命令"));
			message::push(out, message::identifier(arg0));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
invalid_token(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 9;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("invalid token"));
		} break;
		case jp: {
			message::push(out, String("無効のトークン"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

} // namespace lexer

namespace parser {
FORCE_INLINE global void
expected_type(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 10;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a type"));
		} break;
		case jp: {
			message::push(out, String("タイプが期待した"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
expected_label_or_import(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 11;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a label or import"));
		} break;
		case jp: {
			message::push(out, String("名札か輸入が期待した"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
expected_identifier(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 12;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected an identifier"));
		} break;
		case jp: {
			message::push(out, String("識別名が期待した"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
expected_import_directive(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 13;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected an import directive"));
		} break;
		case jp: {
			message::push(out, String("輸入命令が期待した"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
expected_colon_for_label(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 14;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a ':' after label(s)"));
		} break;
		case jp: {
			message::push(out, String("ラベルの後にコロンが必要"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
expected_comma_or_closing_paren_tuple(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 15;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a ',' or ')' for tuple"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
unexpected_token(MessageSender sender, Token* arg0) {
	Diagnostic diag = {0};
	diag.code = 16;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("unexpected token "));
			message::push(out, arg0);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
expected_open_paren(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 17;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a '('"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
expected_close_paren(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 18;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a ')'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
expected_open_brace(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 19;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a '{'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
expected_close_brace(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 20;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a '}'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
label_group_missing_id(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 21;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("trailing comma not allowed in multi-label declaration"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
label_missing_colon(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 22;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing a ':' after label identifier(s)"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
switch_missing_open_paren(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 23;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing a '(' after 'switch'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
switch_missing_close_paren(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 24;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing a ')' after switch's expression"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
switch_missing_open_brace(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 25;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing a '{' to start switch expression"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
switch_empty_body(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 26;
	diag.severity = diagnostic::warning;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::warning;
	switch(lang) {
		case en: {
			message::push(out, String("empty switch body"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
switch_missing_match_arrow_after_expr(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 27;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a '=>' after expression in switch expression"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
switch_missing_comma_after_match_arm(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 28;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a ',' after switch arm that does not end with a '}'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
tuple_expected_comma_or_close_paren(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 29;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a ',' or ')' for tuple"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
if_missing_open_paren(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 30;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing '(' after 'if'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
if_missing_close_paren(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 31;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing ')' after if expression's condition"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
missing_semicolon(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 32;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing ';'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
missing_function_return_type(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 33;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing return type(s) for function"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
missing_open_brace_for_struct(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 34;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing '{' after 'struct'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
struct_only_labels_allowed(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 35;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("only labels are allowed in structures"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
struct_member_functions_not_allowed(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 36;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("member functions are not allowed"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
extraneous_close_brace(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 37;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("extraneous closing blace '}'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE global void
unexpected_token_in_module(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 38;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("unexpected token in module, only labels and directives are allowed"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

} // namespace parser

namespace internal {
FORCE_INLINE global void
valid_path_but_internal_err(MessageSender sender, String arg0, String arg1) {
	Diagnostic diag = {0};
	diag.code = 39;
	diag.severity = diagnostic::error;
	if(!sender.type) array::push(::amu::compiler::instance.diagnostics, diag);
	else array::push(sender.source->diagnostics, diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("valid path, "));
			message::push(out, message::path(arg0));
			message::push(out, String(", was given, but couldn't be opened due to an internal error: "));
			message::push(out, arg0);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

} // namespace internal

} // namespace diagnostic
} // namespace amu
