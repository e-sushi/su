/* 1696904566 [2023/10/09 19:22:46]
    generated by diagnostics.raku from diagnostics.def
*/
namespace amu {
namespace diagnostic {
language lang;
namespace path {
FORCE_INLINE void not_found(MessageSender sender, String arg0) {
	Diagnostic diag = {0};
	diag.code = 1;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("the path "));
			message::push(out, message::path(arg0));
			message::push(out, String(" could not be found"));
		} break;
		case esp: {
			message::push(out, String("la vojo "));
			message::push(out, message::path(arg0));
			message::push(out, String(" maltroveblis"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

} // namespace path

namespace compiler {
FORCE_INLINE void expected_a_path_for_arg(MessageSender sender, String arg0) {
	Diagnostic diag = {0};
	diag.code = 2;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a path for arg '"));
			message::push(out, arg0);
			message::push(out, String("'"));
		} break;
		case esp: {
			message::push(out, String("atendis vojopor argumento '"));
			message::push(out, arg0);
			message::push(out, String("'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void unknown_option(MessageSender sender, String arg0) {
	Diagnostic diag = {0};
	diag.code = 3;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("unknown option '"));
			message::push(out, arg0);
			message::push(out, String("'"));
		} break;
		case esp: {
			message::push(out, String("nekonata opcio '"));
			message::push(out, arg0);
			message::push(out, String("'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void no_path_given(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 4;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("no input file"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void expected_path_or_paths_for_arg_option(MessageSender sender, String arg0) {
	Diagnostic diag = {0};
	diag.code = 5;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a path or paths for argument option '"));
			message::push(out, arg0);
			message::push(out, String("'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

} // namespace compiler

namespace lexer {
FORCE_INLINE void unexpected_eof_single_quotes(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 6;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("unexpected EOF encountered while parsing single quotes"));
		} break;
		case jp: {
			message::push(out, String("一重引用符は解析すながら予期せぬファイルの終わり見つかり"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void unexpected_eof_double_quotes(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 7;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("unexpected EOF encountered while parsing double quotes"));
		} break;
		case jp: {
			message::push(out, String("二重引用符は解析すながら予期せぬファイルの終わり見つかり"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void multiline_comment_missing_end(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 8;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("multiline comment missing '*/'"));
		} break;
		case jp: {
			message::push(out, String("複数行コメントの'*/'がぬけています"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void unknown_directive(MessageSender sender, String arg0) {
	Diagnostic diag = {0};
	diag.code = 9;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("unknown directive "));
			message::push(out, message::identifier(arg0));
		} break;
		case jp: {
			message::push(out, String("不明の命令"));
			message::push(out, message::identifier(arg0));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void unknown_svar(MessageSender sender, String arg0) {
	Diagnostic diag = {0};
	diag.code = 10;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("unknown special id "));
			message::push(out, message::identifier(arg0));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void invalid_token(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 11;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("invalid token"));
		} break;
		case jp: {
			message::push(out, String("無効のトークン"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void filename_cant_be_identifier(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 12;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("the name of this source file cannot be used as an identifier"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

} // namespace lexer

namespace parser {
FORCE_INLINE void expected_type(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 13;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a type"));
		} break;
		case jp: {
			message::push(out, String("タイプが期待した"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void expected_label_or_import(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 14;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a label or import"));
		} break;
		case jp: {
			message::push(out, String("名札か輸入が期待した"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void expected_identifier(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 15;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected an identifier"));
		} break;
		case jp: {
			message::push(out, String("識別名が期待した"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void expected_import_directive(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 16;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected an import directive"));
		} break;
		case jp: {
			message::push(out, String("輸入命令が期待した"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void expected_colon_for_label(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 17;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a ':' after label(s)"));
		} break;
		case jp: {
			message::push(out, String("ラベルの後にコロンが必要"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void unknown_identifier(MessageSender sender, Token* arg0) {
	Diagnostic diag = {0};
	diag.code = 18;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("reference to unknown identifier: "));
			message::push(out, arg0);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void label_already_defined(MessageSender sender, Token* arg0) {
	Diagnostic diag = {0};
	diag.code = 19;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("the label "));
			message::push(out, arg0);
			message::push(out, String(" has already been defined in this scope"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void missing_close_brace(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 20;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing a close brace for this opening brace (I think)"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void expected_comma_or_closing_paren_tuple(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 21;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a ',' or ')' for tuple"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void unexpected_token(MessageSender sender, Token* arg0) {
	Diagnostic diag = {0};
	diag.code = 22;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("unexpected token "));
			message::push(out, arg0);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void expected_open_paren(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 23;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a '('"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void expected_close_paren(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 24;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a ')'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void expected_open_brace(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 25;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a '{'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void expected_close_brace(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 26;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a '}'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void label_group_missing_id(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 27;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("trailing comma not allowed in multi-label declaration"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void label_missing_colon(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 28;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing a ':' after label identifier(s)"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void switch_missing_open_paren(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 29;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing a '(' after 'switch'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void switch_missing_close_paren(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 30;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing a ')' after switch's expression"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void switch_missing_open_brace(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 31;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing a '{' to start switch expression"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void switch_empty_body(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 32;
	diag.severity = diagnostic::warning;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::warning;
	switch(lang) {
		case en: {
			message::push(out, String("empty switch body"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void switch_missing_match_arrow_after_expr(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 33;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a '=>' after expression in switch expression"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void switch_missing_comma_after_match_arm(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 34;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a ',' after switch arm that does not end with a '}'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void for_missing_open_paren(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 35;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing a '(' after 'for'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void for_missing_close_paren(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 36;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing a ')' after for's expression"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void for_expected_some_identfier(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 37;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected some identifier to begin 'for' clause"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void for_label_group_not_allowed(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 38;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("multi label definition is not allowed in C style for loops."));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void for_expected_in(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 39;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected 'in' for 'for' clause"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void for_cannot_declare_variables(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 40;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("cannot declare variables in for clause TODO(sushi) this may be confusing, we just don't allow ':' or '=' after labels in for clauses"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void tuple_expected_comma_or_close_paren(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 41;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a ',' or ')' for tuple"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void array_expected_comma_or_close_square(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 42;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a ',' or ']' for array"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void tuple_positional_arg_but_found_label(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 43;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("all elements after a named tuple element must also be named"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void if_missing_open_paren(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 44;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing '(' after 'if'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void if_missing_close_paren(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 45;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing ')' after if expression's condition"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void missing_semicolon(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 46;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing ';'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void missing_function_return_type(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 47;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing return type(s) for function"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void missing_open_brace_for_struct(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 48;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing '{' after 'struct'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void struct_only_labels_allowed(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 49;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("only labels are allowed in structures"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void struct_member_functions_not_allowed(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 50;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("member functions are not allowed"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void extraneous_close_brace(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 51;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("extraneous closing blace '}'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void unexpected_token_in_module(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 52;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("unexpected token in module, only labels and directives are allowed"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void array_missing_close_square(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 53;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing ']' to close array type"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void runtime_structures_not_allowed(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 54;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("structure types cannot be defined in runtime memory (did you forget a ':'? or did you use '=' instead of ':'?)"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void struct_duplicate_member_name(MessageSender sender, Token* arg0) {
	Diagnostic diag = {0};
	diag.code = 55;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("member "));
			message::push(out, arg0);
			message::push(out, String(" already defined."));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void static_array_count_must_eval_to_integer(MessageSender sender, Type* arg0) {
	Diagnostic diag = {0};
	diag.code = 56;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("static array count must evaluate to a compile time integer, but found "));
			message::push(out, arg0);
			message::push(out, String(" instead"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void static_array_size_cannot_be_negative(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 57;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("static array count cannot be negative"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void subscript_missing_close_square(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 58;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("subscript operator missing closing square ']'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void runtime_variable_cannot_be_used_as_static_array_count(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 59;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("a runtime variable cannot be used to size a static array"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void intrinsic_print_missing_parenthesis(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 60;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("special id $print is a function but is not followed by an argument tuple"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void intrinsic_print_empty(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 61;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("empty intrinsic print"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void tuple_type_plain_expression(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 62;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("elements of a type tuple cannot be plain expressions"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void tuple_type_expression_must_be_explicitly_typed(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 63;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("a type tuple element declared without a label must be explicitly typed (via a cast, binary assignment with a type on the lhs, etc.)"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void missing_open_brace_for_module(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 64;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("missing '{' after 'module'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

} // namespace parser

namespace sema {
FORCE_INLINE void func_ret_expected_typeref(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 65;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expected a type reference for function return type"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void cannot_implict_coerce(MessageSender sender, Type* from_type, Type* to_type) {
	Diagnostic diag = {0};
	diag.code = 66;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("the type "));
			message::push(out, from_type);
			message::push(out, String(" does not define trait ImplicitCast to type "));
			message::push(out, to_type);
		} break;
		case esp: {
			message::push(out, String("la tipo "));
			message::push(out, from_type);
			message::push(out, String(" ne difinas la trajton ImplicitCast al tipo "));
			message::push(out, to_type);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void cant_find_binop_trait(MessageSender sender, String trait_name, Type* arg1, Type* arg2) {
	Diagnostic diag = {0};
	diag.code = 67;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("the trait "));
			message::push(out, trait_name);
			message::push(out, String(" is not defined between "));
			message::push(out, arg1);
			message::push(out, String(" and "));
			message::push(out, arg2);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void mismatch_argument_type(MessageSender sender, Type* arg_type, Type* param_type, String arg_str, String func_name) {
	Diagnostic diag = {0};
	diag.code = 68;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("cannot convert type "));
			message::push(out, arg_type);
			message::push(out, String(" to "));
			message::push(out, param_type);
			message::push(out, String(" for argument "));
			message::push(out, arg_str);
			message::push(out, String(" in call to "));
			message::push(out, func_name);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void too_many_arguments(MessageSender sender, String arg0) {
	Diagnostic diag = {0};
	diag.code = 69;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("too many arguments provided in call to "));
			message::push(out, arg0);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void not_enough_arguments(MessageSender sender, String arg0) {
	Diagnostic diag = {0};
	diag.code = 70;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("not enough arguments provided in call to "));
			message::push(out, arg0);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void invalid_type_lhs_access(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 71;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("unable to resolve the type of the lhs of access operator"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void cannot_access_members_scalar_type(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 72;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("scalar types have no members"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void array_types_dont_have_member(MessageSender sender, String arg0) {
	Diagnostic diag = {0};
	diag.code = 73;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("array types dont have a member "));
			message::push(out, arg0);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void cannot_access_members_of_function_type(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 74;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("cannot access members of a function type"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void too_many_levels_of_indirection_for_access(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 75;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("too many levels of indirection for access operator. The access operator will only dereference once."));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void unknown_member(MessageSender sender, Type* type, String member_name) {
	Diagnostic diag = {0};
	diag.code = 76;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("type "));
			message::push(out, type);
			message::push(out, String(" has no member named "));
			message::push(out, member_name);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void module_unknown_member(MessageSender sender, String module_name, String member_name) {
	Diagnostic diag = {0};
	diag.code = 77;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("module "));
			message::push(out, message::identifier(module_name));
			message::push(out, String(" has no member "));
			message::push(out, member_name);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void cannot_have_a_variable_of_void_type(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 78;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("cannot create a variable of type 'void'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void if_mismatched_types_cannot_coerce(MessageSender sender, Type* first_type, Type* later_type) {
	Diagnostic diag = {0};
	diag.code = 79;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("conditional branches have mismatched types and the ladder type "));
			message::push(out, first_type);
			message::push(out, String(" cannot be converted to the former "));
			message::push(out, later_type);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void return_value_of_func_block_cannot_be_coerced_to_func_return_type(MessageSender sender, Type* func_type, Type* block_type) {
	Diagnostic diag = {0};
	diag.code = 80;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("function return type declared as "));
			message::push(out, func_type);
			message::push(out, String(" but block returns "));
			message::push(out, block_type);
			message::push(out, String(" and "));
			message::push(out, block_type);
			message::push(out, String(" does not define ImplicitCast to "));
			message::push(out, func_type);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void break_outside_of_loop(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 81;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("break expressions must be used in loops"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void cant_use_whatever_as_value(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 82;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("type Whatever cannot be used as a value"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void cant_use_whatever_as_variable_type(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 83;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("cannot have a variable of type Whatever"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void control_expressions_can_only_be_used_at_the_end_of_logical_operators(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 84;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("control expressions can only be used at the very right of logical operators"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void compile_time_code_cannot_reference_runtime_memory(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 85;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("compile time code cannot reference runtime memory"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void array_literal_type_mismatch(MessageSender sender, s64 elem_index, Type* bad_type, Type* first_type) {
	Diagnostic diag = {0};
	diag.code = 86;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("array element "));
			message::push(out, to_string(elem_index)->fin);
			message::push(out, String(" is of type "));
			message::push(out, bad_type);
			message::push(out, String(" which does not define ImplicitCast to the first element's type "));
			message::push(out, first_type);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void static_array_count_expr_not_compile_time(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 87;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("an expression used to set the size of a static array must be computable at compile time"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void static_array_expr_must_resolve_to_integer(MessageSender sender, Type* arg0) {
	Diagnostic diag = {0};
	diag.code = 88;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("the expression of a static array must result in an integer, but this expression results in a "));
			message::push(out, arg0);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void static_array_size_cannot_be_negative(MessageSender sender, s64 arg0) {
	Diagnostic diag = {0};
	diag.code = 89;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("static array size cannot be negative, but this expression results in: "));
			message::push(out, to_string(arg0)->fin);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void type_is_not_subscriptable(MessageSender sender, Type* arg0) {
	Diagnostic diag = {0};
	diag.code = 90;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("the type "));
			message::push(out, arg0);
			message::push(out, String(" cannot be subscripted"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void subscript_must_evaluate_to_integer(MessageSender sender, Type* arg0) {
	Diagnostic diag = {0};
	diag.code = 91;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("a subscript must evaluate to an integer (or, eventually, a range of integers), but this evaluates to "));
			message::push(out, arg0);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void subscript_out_of_bounds(MessageSender sender, s64 bad_guy, s64 array_size) {
	Diagnostic diag = {0};
	diag.code = 92;
	diag.severity = diagnostic::warning;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::warning;
	switch(lang) {
		case en: {
			message::push(out, String("the subscript "));
			message::push(out, to_string(bad_guy)->fin);
			message::push(out, String(" is out of bounds of static array of size "));
			message::push(out, to_string(array_size)->fin);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void subscript_negative_not_allowed_on_pointer(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 93;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("negative subscripts on pointers aren't defined"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void comparison_between_pointer_and_scalar(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 94;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("relational operators between pointers and integers are not defined"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void float_in_pointer_arithmetic(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 95;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("floats cannot be used in pointer arithmetic"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void pointer_equality_non_zero_integer(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 96;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("equality operators between a pointer and a non-zero integer are not defined"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void pointer_integer_not_additive(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 97;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("only addition and subtraction are defined between a pointer and an integer"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void pointer_arithmetic_not_additive(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 98;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("only addition and subtraction are defined between pointers and integers"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void pointer_on_rhs_of_arithmetic(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 99;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("arithmetic with a pointer in the rhs is not defined"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void static_array_invalid_member(MessageSender sender, String arg0) {
	Diagnostic diag = {0};
	diag.code = 100;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("unknown member "));
			message::push(out, message::identifier(arg0));
			message::push(out, String(". the only members of a static array are 'data' and 'count'"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void modulo_not_defined_on_floats(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 101;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("modulo is not defined to act on floats (for now)"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void cant_take_reference_of_value(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 102;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("cannot reference a value (something that is not in memory). NOTE if this seems wrong let me know! Currently you can only take references of variables"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void reference_operator_can_only_be_used_on_types_or_lvalues(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 103;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("the reference operator '&' can only be used before typerefs (to denote a pointer) or before lvalues (to take the address of something)"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void dereference_operator_only_works_on_pointers(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 104;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("dereference operator '*' may only be used on pointers"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void range_mismatched_types(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 105;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("boths sides of a Range must have the same type or types castable to each other"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void range_non_scalar_not_supported(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 106;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("non-scalar ranges are not supported yet"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void casting_between_non_scalar_types_not_supported(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 107;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("casting between non-scalar types is not supported yet"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void intrinsic_print_named_arg(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 108;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("naming an argument to intrinsic print is not defined yet"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void unary_comptime_expr_not_comptime(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 109;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("the expression following this ':' is not able to be computed at compile time"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void static_array_unusally_large(MessageSender sender, String arg0) {
	Diagnostic diag = {0};
	diag.code = 110;
	diag.severity = diagnostic::warning;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::warning;
	switch(lang) {
		case en: {
			message::push(out, String("static array defined with an unusually large size: "));
			message::push(out, arg0);
			message::push(out, String(". possible unsigned underflow"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void tuple_struct_initializer_unknown_member(MessageSender sender, String arg0, Type* arg1) {
	Diagnostic diag = {0};
	diag.code = 111;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("the id "));
			message::push(out, message::identifier(arg0));
			message::push(out, String(" used in tuple initializer does not match any member of type "));
			message::push(out, arg1);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void tuple_struct_initializer_cannot_cast_expr_to_member(MessageSender sender, Type* arg0, String arg1, Type* arg2) {
	Diagnostic diag = {0};
	diag.code = 112;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("expression of type "));
			message::push(out, arg0);
			message::push(out, String(" cannot be casted to the matching structure member "));
			message::push(out, message::identifier(arg1));
			message::push(out, String(" of type "));
			message::push(out, arg2);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void tuple_struct_initializer_named_member_already_satisfied(MessageSender sender, String arg0) {
	Diagnostic diag = {0};
	diag.code = 113;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("member "));
			message::push(out, message::identifier(arg0));
			message::push(out, String(" was previously set by an element of this tuple literal"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void tuple_struct_initializer_too_many_elements(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 114;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("too many elements provided in struct initializer"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

FORCE_INLINE void tuple_cast_to_structured_not_yet_supported(MessageSender sender) {
	Diagnostic diag = {0};
	diag.code = 115;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("casting a non literal Tuple to a Structured type is not supported yet"));
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

} // namespace sema

namespace internal {
FORCE_INLINE void valid_path_but_internal_err(MessageSender sender, String arg0, String arg1) {
	Diagnostic diag = {0};
	diag.code = 116;
	diag.severity = diagnostic::error;
	if(!sender.type) ::amu::compiler::instance.diagnostics.push(diag);
	else sender.code->add_diagnostic(diag);
	Message out = message::init();
	out.kind = message::error;
	switch(lang) {
		case en: {
			message::push(out, String("valid path, "));
			message::push(out, message::path(arg0));
			message::push(out, String(", was given, but couldn't be opened due to an internal error: "));
			message::push(out, arg1);
		} break;
	}
	out = message::attach_sender(sender, out);
	messenger::dispatch(out);
}

} // namespace internal

} // namespace diagnostic
} // namespace amu
