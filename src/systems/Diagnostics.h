/*

	Localized messages intended to inform the user about whats
	being compiled and such.

	TODOS
	-----
	Dynamic generation

	Add reference counting so that diags can be easily discarded.

*/

#ifndef AMU_DIAGNOSTICS_H
#define AMU_DIAGNOSTICS_H

// TODO(sushi) remove the dynamic array of args when this is generated by the script
//             probably just use 

#define try(x) if(!x) return false;

#include "Messenger.h"

namespace amu {

struct Token;
struct Type;

namespace diagnostic {
// #include "data/diagnostics-data.generated"
// extern language lang;
}


enum class Lang {
	English,
	Esperanto,
	Japanese,
	COUNT,
};

extern Lang language;

struct Diag {
	enum class Kind {
		InvalidToken,
		UnknownSid,
		UnknownDirective,
		ExpectedAPathForArg,
		ExpectedPathOrPathsForArgOption,
		UnknownOption,
		NoPathGiven,
	};


	Kind kind;
	Message::Kind severity;

	MessageSender sender;

	union Arg {
		String string;
		Token* token;
		Type* type;
	};

	Array<Arg> args;

	Message (*emit_callback)(Diag*);

	void
	emit() {
		messenger.dispatch(emit_callback(this));
	}

	static Diag 
	create(MessageSender sender, Kind kind, Message::Kind severity, s32 n_args) {
		Diag out;
		out.kind = kind;
		out.severity = severity;
		out.sender = sender;
		if(n_args) {
			out.args = Array<Arg>::create();
			out.args.resize(n_args);
		}
		return out;
	}

	void
	destroy() {
		args.destroy();
	}

	static Diag
	no_path_given(MessageSender m) {
		auto out = Diag::create(m, Kind::NoPathGiven, Message::Kind::Fatal, 0);
		out.emit_callback = [](Diag* diag) -> Message {
			switch(language) {
				default:
				case Lang::English:
					return MessageBuilder::
						 start(diag->sender, diag->severity)
						.append("no input files were given")
						.message;
			}
		};
		return out;
	}
	static void no_path_given(Array<Diag>& to, MessageSender m) { to.push(no_path_given(m)); }

	static Diag
	expected_a_path_for_arg(MessageSender m, String arg) {
		auto out = Diag::create(m, Kind::ExpectedAPathForArg, Message::Kind::Fatal, 1);
		out.args[0].string = arg;
		out.emit_callback = [](Diag* diag) -> Message {
			return MessageBuilder::
				 start(diag->sender, diag->severity)
				.append("expected a path for arg '")
				.append(diag->args[0].string)
				.append("'")
				.message;
		};
		return out;
	}
	static void expected_a_path_for_arg(Array<Diag>& to, MessageSender m, String arg) { to.push(expected_a_path_for_arg(m, arg)); }

	static Diag
	expected_path_or_paths_for_arg_option(MessageSender m, String arg) {
		auto out = Diag::create(m, Kind::ExpectedPathOrPathsForArgOption, Message::Kind::Fatal, 1);
		out.args[0].string = arg;
		out.emit_callback = [](Diag* diag) -> Message {
			switch(language) {
				default:
				case Lang::English: 
					return MessageBuilder::
						 start(diag->sender, diag->severity)
						.append("expected a path or paths for arg option '")
						.append(diag->args[0].string)
						.append("'")
						.message;
			}
		};
		return out;
	}

	static Diag
	unknown_option(MessageSender m, String arg) {
		auto out = Diag::create(m, Kind::UnknownOption, Message::Kind::Fatal, 1);
		out.args[0].string = arg;
		out.emit_callback = [](Diag* diag) -> Message {
			switch(language) {
				default:
				case Lang::English:
					return MessageBuilder::
						 start(diag->sender, diag->severity)
						.append("unknown cli option '")
						.append(diag->args[0].string)
						.append("'")
						.message;
			}
		};
		return out;
	}
	static void unknown_option(Array<Diag>& to, MessageSender m, String arg) { to.push(unknown_option(m, arg)); }

	static Diag
	invalid_token(MessageSender m, Token* tok) {
		auto out = Diag::create(m, Kind::InvalidToken, Message::Kind::Error, 1);
		out.args[0].token = tok;
		out.emit_callback = [](Diag* diag) -> Message {
			return MessageBuilder::
				 start(diag->sender, diag->severity)
				.append("invalid token: ")
				.append(diag->args[0].token)
				.message;
		};
		return out;
	}

	static Diag
	unknown_sid(MessageSender m, String s) {
		auto out = Diag::create(m, Kind::UnknownSid, Message::Kind::Error, 1);
		out.args[0].string = s;
		out.emit_callback = [](Diag* diag) -> Message {
			return MessageBuilder::
				 start(diag->sender, diag->severity)
				.append("unknown special id: ")
				.append(diag->args[0].string)
				.message;
		};
		return out;
	}

	static Diag
	unknown_directive(MessageSender m, String s) {
		auto out = Diag::create(m, Kind::UnknownDirective, Message::Kind::Error, 1);
		out.args[0].string = s;
		out.emit_callback = [](Diag* diag) -> Message {
			return MessageBuilder::
				 start(diag->sender, diag->severity)
				.append("unknown directive: ")
				.append(diag->args[0].string)
				.message;
		};
		return out;
	}

};

} // namespace amu
  
#include "data/diagnostic-header.generated"

#endif // AMU_DIAGNOSTICS_H
